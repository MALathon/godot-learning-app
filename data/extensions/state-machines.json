{
  "topicId": "state-machines",
  "resources": [
    {
      "title": "Godot Documentation - State Design Pattern",
      "url": "https://docs.godotengine.org/en/stable/tutorials/misc/state_design_pattern.html",
      "type": "docs",
      "addedAt": "2026-01-16T05:11:38.760Z",
      "addedBy": "ai"
    },
    {
      "title": "Godot Documentation - Finite State Machine",
      "url": "https://docs.godotengine.org/en/stable/tutorials/misc/state_design_pattern.html",
      "type": "docs",
      "addedAt": "2026-01-16T05:12:05.308Z",
      "addedBy": "ai"
    },
    {
      "title": "GDQuest - State Machine Tutorial",
      "url": "https://www.gdquest.com/tutorial/godot/design-patterns/finite-state-machine/",
      "type": "video",
      "addedAt": "2026-01-16T05:12:08.888Z",
      "addedBy": "ai"
    }
  ],
  "codeExamples": [
    {
      "title": "Tic-Tac-Toe Game State Machine",
      "language": "gdscript",
      "code": "# Base State class - all states implement this interface\nextends RefCounted\nclass_name GameState\n\nvar game_manager: Node\n\nfunc _init(manager: Node):\n    game_manager = manager\n\n# Override these in concrete states\nfunc enter():\n    pass\n\nfunc exit():\n    pass\n\nfunc handle_input(event: InputEvent):\n    pass\n\nfunc update(delta: float):\n    pass\n\n---\n\n# Concrete States for Tic-Tac-Toe\nextends GameState\nclass_name MenuState\n\nfunc enter():\n    print(\"Entered Menu State\")\n    game_manager.show_menu()\n    game_manager.hide_board()\n\nfunc handle_input(event: InputEvent):\n    if event.is_action_pressed(\"start_game\"):\n        game_manager.change_state(\"playing\")\n\n---\n\nextends GameState  \nclass_name PlayingState\n\nfunc enter():\n    print(\"Entered Playing State\")\n    game_manager.hide_menu()\n    game_manager.show_board()\n    game_manager.reset_board()\n    game_manager.current_player = \"X\"\n\nfunc handle_input(event: InputEvent):\n    if event.is_action_pressed(\"pause\"):\n        game_manager.change_state(\"paused\")\n\nfunc handle_cell_click(cell_position: Vector2):\n    if not game_manager.is_cell_empty(cell_position):\n        return\n        \n    # Make move\n    game_manager.set_cell(cell_position, game_manager.current_player)\n    \n    # Check win condition\n    if game_manager.check_win(game_manager.current_player):\n        game_manager.winner = game_manager.current_player\n        game_manager.change_state(\"game_over\")\n    elif game_manager.is_board_full():\n        game_manager.winner = \"draw\"\n        game_manager.change_state(\"game_over\")\n    else:\n        # Switch players\n        game_manager.current_player = \"O\" if game_manager.current_player == \"X\" else \"X\"\n\n---\n\nextends GameState\nclass_name PausedState\n\nfunc enter():\n    print(\"Entered Paused State\")\n    game_manager.show_pause_menu()\n    get_tree().paused = true\n\nfunc exit():\n    get_tree().paused = false\n    game_manager.hide_pause_menu()\n\nfunc handle_input(event: InputEvent):\n    if event.is_action_pressed(\"resume\"):\n        game_manager.change_state(\"playing\")\n    elif event.is_action_pressed(\"quit_to_menu\"):\n        game_manager.change_state(\"menu\")\n\n---\n\nextends GameState\nclass_name GameOverState\n\nfunc enter():\n    print(\"Entered Game Over State\")\n    if game_manager.winner == \"draw\":\n        game_manager.show_message(\"It's a draw!\")\n    else:\n        game_manager.show_message(game_manager.winner + \" wins!\")\n    \n    # Auto-transition to menu after 3 seconds\n    game_manager.get_tree().create_timer(3.0).timeout.connect(return_to_menu)\n\nfunc return_to_menu():\n    game_manager.change_state(\"menu\")\n\nfunc handle_input(event: InputEvent):\n    # Allow immediate return to menu\n    if event.is_action_pressed(\"ui_accept\") or event.is_action_pressed(\"ui_cancel\"):\n        game_manager.change_state(\"menu\")\n\n---\n\n# Main Game Manager with State Machine\nextends Node\nclass_name TicTacToeGameManager\n\n# State management\nvar current_state: GameState\nvar states = {}\n\n# Game data\nvar board = []\nvar current_player: String = \"X\"\nvar winner: String = \"\"\n\n# UI references\n@onready var menu_ui = $MenuUI\n@onready var board_ui = $BoardUI\n@onready var pause_ui = $PauseUI\n@onready var message_ui = $MessageUI\n\nfunc _ready():\n    # Initialize board\n    board.resize(9)\n    for i in range(9):\n        board[i] = \"\"\n    \n    # Create states\n    states[\"menu\"] = MenuState.new(self)\n    states[\"playing\"] = PlayingState.new(self)\n    states[\"paused\"] = PausedState.new(self)\n    states[\"game_over\"] = GameOverState.new(self)\n    \n    # Start in menu state\n    change_state(\"menu\")\n\nfunc _input(event: InputEvent):\n    if current_state:\n        current_state.handle_input(event)\n\nfunc _process(delta: float):\n    if current_state:\n        current_state.update(delta)\n\n# State machine management\nfunc change_state(new_state_name: String):\n    if current_state:\n        current_state.exit()\n    \n    current_state = states[new_state_name]\n    \n    if current_state:\n        current_state.enter()\n\n# Game logic methods\nfunc is_cell_empty(pos: Vector2) -> bool:\n    var index = pos.y * 3 + pos.x\n    return board[index] == \"\"\n\nfunc set_cell(pos: Vector2, player: String):\n    var index = pos.y * 3 + pos.x\n    board[index] = player\n    board_ui.update_cell(pos, player)\n\nfunc check_win(player: String) -> bool:\n    # Check rows, columns, diagonals\n    var win_patterns = [\n        [0,1,2], [3,4,5], [6,7,8],  # rows\n        [0,3,6], [1,4,7], [2,5,8],  # columns\n        [0,4,8], [2,4,6]            # diagonals\n    ]\n    \n    for pattern in win_patterns:\n        if board[pattern[0]] == player and board[pattern[1]] == player and board[pattern[2]] == player:\n            return true\n    \n    return false\n\nfunc is_board_full() -> bool:\n    for cell in board:\n        if cell == \"\":\n            return false\n    return true\n\nfunc reset_board():\n    for i in range(9):\n        board[i] = \"\"\n    board_ui.clear_board()\n\n# UI methods\nfunc show_menu():\n    menu_ui.visible = true\n\nfunc hide_menu():\n    menu_ui.visible = false\n\nfunc show_board():\n    board_ui.visible = true\n\nfunc hide_board():\n    board_ui.visible = false\n\nfunc show_pause_menu():\n    pause_ui.visible = true\n\nfunc hide_pause_menu():\n    pause_ui.visible = false\n\nfunc show_message(text: String):\n    message_ui.show_text(text)\n\n# Called by UI when cells are clicked\nfunc _on_cell_clicked(pos: Vector2):\n    if current_state is PlayingState:\n        current_state.handle_cell_click(pos)\n\n---\n\n# Example usage patterns:\n\n# 1. States are self-contained - easy to test and debug\n# 2. Adding new states is simple (AI opponent, online multiplayer)  \n# 3. State transitions are explicit and controlled\n# 4. Each state handles only its relevant input/logic\n# 5. Game logic stays in the manager, states coordinate behavior\n\n# Benefits of State Machine Pattern:\n# - Clear separation of concerns\n# - Easy to add features (new states/transitions)\n# - Bugs are localized to specific states\n# - Game flow is explicit and understandable\n# - Prevents invalid state combinations",
      "explanation": "This demonstrates a finite state machine pattern for a tic-tac-toe game - a clean way to manage different game phases and behaviors.\n\n**State Machine Concepts:**\n\n**What is a State Machine?**\n- A pattern where an object changes behavior based on internal state\n- Only one state is active at a time  \n- States define what actions are valid and how to handle events\n- Transitions between states are explicit and controlled\n\n**Key Components:**\n1. **State Interface** - Base class defining common state methods\n2. **Concrete States** - Specific implementations (Menu, Playing, Paused, GameOver)\n3. **Context/Manager** - Coordinates states and holds shared data\n4. **Transitions** - Rules for moving between states\n\n**Why Use State Machines?**\n- **Clarity** - Game behavior is easy to understand and predict\n- **Maintainability** - Each state's logic is isolated and testable\n- **Extensibility** - Adding features means adding states/transitions\n- **Bug Prevention** - Invalid actions/states are prevented by design\n\n**Real-World Applications:**\n- Game flow (menu → playing → game over)\n- AI behavior (idle → patrol → attack → retreat)\n- Animation systems (idle → walk → jump → fall)\n- UI interactions (normal → hover → pressed → disabled)\n\n**Benefits for Tic-Tac-Toe:**\n- Menu state handles game setup\n- Playing state manages turn-based gameplay  \n- Paused state preserves game state while suspended\n- GameOver state handles win/draw conditions and transitions back\n\nThis pattern scales well - you can easily add states like \"AI Turn\", \"Online Waiting\", or \"Settings\" without disrupting existing code.",
      "addedAt": "2026-01-16T05:12:13.544Z",
      "addedBy": "ai"
    },
    {
      "title": "Tic-Tac-Toe Game State Machine",
      "language": "gdscript",
      "code": "# Tic-Tac-Toe Game State Machine Implementation\n\nextends Node\nclass_name TicTacToeGameManager\n\n# Define all possible game states\nenum GameState {\n    MENU,           # Showing main menu\n    PLAYER_TURN,    # Waiting for player move\n    AI_TURN,        # AI is making a move\n    GAME_OVER,      # Game finished (win/lose/draw)\n    PAUSED          # Game is paused\n}\n\n# State machine variables\nvar current_state: GameState = GameState.MENU\nvar previous_state: GameState\n\n# Game data\nvar board: Array[Array] = []\nvar current_player: String = \"X\"\nvar game_result: String = \"\"\n\n# Signals for state changes\nsignal state_changed(old_state: GameState, new_state: GameState)\nsignal game_finished(result: String)\n\nfunc _ready():\n    initialize_board()\n    change_state(GameState.MENU)\n\nfunc _input(event):\n    # State machine handles input differently based on current state\n    match current_state:\n        GameState.MENU:\n            handle_menu_input(event)\n        GameState.PLAYER_TURN:\n            handle_player_input(event)\n        GameState.PAUSED:\n            handle_pause_input(event)\n        GameState.GAME_OVER:\n            handle_game_over_input(event)\n        # AI_TURN doesn't handle input (AI makes moves automatically)\n\n# CORE STATE MACHINE FUNCTIONS\n\nfunc change_state(new_state: GameState):\n    if new_state == current_state:\n        return  # Already in this state\n    \n    var old_state = current_state\n    \n    # Exit current state\n    exit_state(current_state)\n    \n    # Update state\n    previous_state = current_state\n    current_state = new_state\n    \n    # Enter new state\n    enter_state(current_state)\n    \n    # Emit signal for observers\n    state_changed.emit(old_state, new_state)\n    \n    print(\"State changed: %s -> %s\" % [GameState.keys()[old_state], GameState.keys()[new_state]])\n\nfunc enter_state(state: GameState):\n    \"\"\"Called when entering a new state\"\"\"\n    match state:\n        GameState.MENU:\n            show_main_menu()\n        GameState.PLAYER_TURN:\n            start_player_turn()\n        GameState.AI_TURN:\n            start_ai_turn()\n        GameState.GAME_OVER:\n            show_game_over()\n        GameState.PAUSED:\n            show_pause_menu()\n\nfunc exit_state(state: GameState):\n    \"\"\"Called when leaving a state\"\"\"\n    match state:\n        GameState.MENU:\n            hide_main_menu()\n        GameState.PLAYER_TURN:\n            end_player_turn()\n        GameState.AI_TURN:\n            end_ai_turn()\n        GameState.PAUSED:\n            hide_pause_menu()\n\nfunc update_state(delta: float):\n    \"\"\"Called every frame - state-specific update logic\"\"\"\n    match current_state:\n        GameState.AI_TURN:\n            update_ai_turn(delta)\n        # Other states might not need frame-by-frame updates\n\n# STATE-SPECIFIC IMPLEMENTATIONS\n\nfunc show_main_menu():\n    print(\"Showing main menu\")\n    # Show UI, reset game data, etc.\n\nfunc hide_main_menu():\n    print(\"Hiding main menu\")\n\nfunc start_player_turn():\n    print(\"Player %s turn started\" % current_player)\n    # Highlight available moves, start turn timer, etc.\n\nfunc end_player_turn():\n    print(\"Player turn ended\")\n\nfunc start_ai_turn():\n    print(\"AI turn started\")\n    # Start AI thinking timer/animation\n\nfunc update_ai_turn(delta: float):\n    # Simulate AI \"thinking\" time\n    await get_tree().create_timer(1.0).timeout\n    make_ai_move()\n\nfunc end_ai_turn():\n    print(\"AI turn ended\")\n\nfunc show_game_over():\n    print(\"Game Over: %s\" % game_result)\n    game_finished.emit(game_result)\n\nfunc show_pause_menu():\n    print(\"Game paused\")\n    get_tree().paused = true\n\nfunc hide_pause_menu():\n    print(\"Game unpaused\")\n    get_tree().paused = false\n\n# INPUT HANDLERS (called by _input based on current state)\n\nfunc handle_menu_input(event):\n    if event.is_action_pressed(\"ui_accept\"):\n        start_new_game()\n\nfunc handle_player_input(event):\n    if event.is_action_pressed(\"pause\"):\n        change_state(GameState.PAUSED)\n    elif event is InputEventMouseButton and event.pressed:\n        var cell = get_cell_from_mouse(event.position)\n        if make_move(cell.x, cell.y):\n            # Move successful, check game state\n            if check_game_over():\n                change_state(GameState.GAME_OVER)\n            else:\n                switch_player()\n                change_state(GameState.AI_TURN)\n\nfunc handle_pause_input(event):\n    if event.is_action_pressed(\"pause\"):\n        change_state(previous_state)  # Return to previous state\n\nfunc handle_game_over_input(event):\n    if event.is_action_pressed(\"ui_accept\"):\n        restart_game()\n    elif event.is_action_pressed(\"ui_cancel\"):\n        change_state(GameState.MENU)\n\n# GAME LOGIC FUNCTIONS\n\nfunc start_new_game():\n    initialize_board()\n    current_player = \"X\"\n    change_state(GameState.PLAYER_TURN)\n\nfunc restart_game():\n    start_new_game()\n\nfunc make_move(x: int, y: int) -> bool:\n    if x < 0 or x >= 3 or y < 0 or y >= 3:\n        return false\n    if board[y][x] != \"\":\n        return false\n    \n    board[y][x] = current_player\n    print(\"Move made: %s at (%d, %d)\" % [current_player, x, y])\n    return true\n\nfunc make_ai_move():\n    # Simple AI: find first empty cell\n    for y in 3:\n        for x in 3:\n            if board[y][x] == \"\":\n                make_move(x, y)\n                if check_game_over():\n                    change_state(GameState.GAME_OVER)\n                else:\n                    switch_player()\n                    change_state(GameState.PLAYER_TURN)\n                return\n    \n    # No moves available\n    game_result = \"Draw\"\n    change_state(GameState.GAME_OVER)\n\nfunc switch_player():\n    current_player = \"O\" if current_player == \"X\" else \"X\"\n\nfunc check_game_over() -> bool:\n    # Check for winner\n    var winner = check_winner()\n    if winner != \"\":\n        game_result = \"Player %s wins!\" % winner\n        return true\n    \n    # Check for draw\n    if is_board_full():\n        game_result = \"It's a draw!\"\n        return true\n    \n    return false\n\nfunc check_winner() -> String:\n    # Check rows, columns, and diagonals\n    # ... (implementation details)\n    return \"\"  # No winner yet\n\nfunc is_board_full() -> bool:\n    for row in board:\n        for cell in row:\n            if cell == \"\":\n                return false\n    return true\n\nfunc initialize_board():\n    board.clear()\n    for i in 3:\n        var row = [\"\", \"\", \"\"]\n        board.append(row)\n\nfunc get_cell_from_mouse(position: Vector2) -> Vector2i:\n    # Convert mouse position to board coordinates\n    # ... (implementation details)\n    return Vector2i(0, 0)\n\n# UTILITY FUNCTIONS\n\nfunc get_current_state_name() -> String:\n    return GameState.keys()[current_state]\n\nfunc can_make_move() -> bool:\n    return current_state == GameState.PLAYER_TURN\n\nfunc can_pause() -> bool:\n    return current_state in [GameState.PLAYER_TURN, GameState.AI_TURN]",
      "explanation": "This example demonstrates a complete state machine implementation for a tic-tac-toe game, showcasing key state machine concepts:\n\n**Core State Machine Pattern:**\n- **States as Enum**: Clear, type-safe state definitions\n- **State Transitions**: Controlled via `change_state()` function\n- **Entry/Exit Actions**: `enter_state()` and `exit_state()` handle state-specific setup/cleanup\n- **State-Specific Behavior**: Different input handling and update logic per state\n\n**Game State Management:**\n- **MENU**: Game start screen\n- **PLAYER_TURN**: Waiting for human player input\n- **AI_TURN**: AI is calculating and making a move\n- **GAME_OVER**: Displaying results and waiting for restart/menu\n- **PAUSED**: Game temporarily suspended\n\n**Key Benefits:**\n1. **Clear Logic Flow**: Each state has specific responsibilities\n2. **Easy to Debug**: Current state is always visible and traceable\n3. **Extensible**: Adding new states (like TUTORIAL, SETTINGS) is straightforward\n4. **Input Management**: Different states handle input differently\n5. **State Validation**: Prevents invalid operations (can't make moves during AI turn)\n\n**State Machine Best Practices Shown:**\n- **Single Responsibility**: Each state has one clear purpose\n- **Controlled Transitions**: States can only transition through the `change_state()` function\n- **State History**: Tracks previous state for pause/resume functionality\n- **Signal Communication**: Emits signals for UI updates and other systems\n- **Validation**: Checks if transitions are valid/necessary\n\n**Practical Applications:**\n- Player character states (idle, walking, jumping, attacking)\n- Menu systems (main menu, options, pause, game over)\n- Game modes (playing, cutscene, inventory, dialogue)\n- AI behavior (patrolling, chasing, attacking, fleeing)\n\nThis pattern scales well from simple games to complex systems with dozens of states and helps maintain clean, predictable code as your game grows in complexity.",
      "addedAt": "2026-01-16T05:15:02.809Z",
      "addedBy": "ai"
    }
  ]
}