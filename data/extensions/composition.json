{
  "topicId": "composition",
  "resources": [
    {
      "title": "Godot Documentation - Composition Over Inheritance",
      "url": "https://docs.godotengine.org/en/stable/tutorials/best_practices/node_alternatives.html",
      "type": "docs",
      "addedAt": "2026-01-16T05:10:09.721Z",
      "addedBy": "ai"
    },
    {
      "title": "Godot Documentation - Composition vs Inheritance",
      "url": "https://docs.godotengine.org/en/stable/tutorials/best_practices/node_alternatives.html",
      "type": "docs",
      "addedAt": "2026-01-16T05:10:20.820Z",
      "addedBy": "ai"
    },
    {
      "title": "GDQuest - Component Architecture in Godot",
      "url": "https://www.gdquest.com/tutorial/godot/design-patterns/component-system/",
      "type": "video",
      "addedAt": "2026-01-16T05:10:21.416Z",
      "addedBy": "ai"
    }
  ],
  "codeExamples": [
    {
      "title": "Tic-Tac-Toe: Component-Based Design",
      "language": "gdscript",
      "code": "# AVOID: Deep inheritance hierarchy (hard to maintain)\n# extends GamePiece -> extends InteractiveGamePiece -> extends AnimatedGamePiece -> extends TicTacToeCell\n\n# PREFER: Composition with focused components\n\n# Component 1: Handles visual representation\nextends Node\nclass_name VisualComponent\n\n@export var normal_texture: Texture2D\n@export var hover_texture: Texture2D\n@export var selected_texture: Texture2D\n\nvar sprite: Sprite2D\n\nfunc _ready():\n    sprite = get_parent().find_child(\"Sprite2D\")\n\nfunc show_normal():\n    sprite.texture = normal_texture\n\nfunc show_hover():\n    sprite.texture = hover_texture\n\nfunc show_selected():\n    sprite.texture = selected_texture\n\n---\n\n# Component 2: Handles user interaction\nextends Node\nclass_name InteractableComponent\n\nsignal clicked\nsignal hover_started\nsignal hover_ended\n\n@export var enabled: bool = true\n\nfunc _ready():\n    var parent = get_parent()\n    if parent.has_signal(\"gui_input\"):\n        parent.gui_input.connect(_on_gui_input)\n\nfunc _on_gui_input(event: InputEvent):\n    if not enabled:\n        return\n        \n    if event is InputEventMouseButton and event.pressed:\n        clicked.emit()\n    elif event is InputEventMouseMotion:\n        # Handle hover logic\n        pass\n\n---\n\n# Component 3: Handles animation effects\nextends Node\nclass_name AnimationComponent\n\n@export var click_scale: float = 0.9\n@export var hover_scale: float = 1.1\n@export var animation_duration: float = 0.15\n\nvar tween: Tween\nvar target_node: Node2D\n\nfunc _ready():\n    target_node = get_parent()\n\nfunc animate_click():\n    if tween:\n        tween.kill()\n    \n    tween = create_tween()\n    tween.tween_property(target_node, \"scale\", Vector2.ONE * click_scale, animation_duration)\n    tween.tween_property(target_node, \"scale\", Vector2.ONE, animation_duration)\n\nfunc animate_hover():\n    if tween:\n        tween.kill()\n    \n    tween = create_tween()\n    tween.tween_property(target_node, \"scale\", Vector2.ONE * hover_scale, animation_duration)\n\n---\n\n# Main node: Composes behaviors instead of inheriting\nextends Control\nclass_name TicTacToeCell\n\n@onready var visual: VisualComponent = $VisualComponent\n@onready var interaction: InteractableComponent = $InteractableComponent  \n@onready var animation: AnimationComponent = $AnimationComponent\n\nvar cell_value: String = \"\"\nvar is_occupied: bool = false\n\nsignal cell_selected\n\nfunc _ready():\n    # Connect component signals to coordinate behavior\n    interaction.clicked.connect(_on_clicked)\n    interaction.hover_started.connect(_on_hover_started)\n    interaction.hover_ended.connect(_on_hover_ended)\n\nfunc _on_clicked():\n    if not is_occupied:\n        animation.animate_click()\n        cell_selected.emit()\n\nfunc _on_hover_started():\n    if not is_occupied:\n        visual.show_hover()\n        animation.animate_hover()\n\nfunc _on_hover_ended():\n    if not is_occupied:\n        visual.show_normal()\n\nfunc set_value(value: String):\n    cell_value = value\n    is_occupied = true\n    visual.show_selected()\n    interaction.enabled = false\n\n# Easy to extend: just add more components!\n# - SoundComponent for audio feedback\n# - EffectComponent for particles\n# - NetworkComponent for multiplayer\n# Each component is focused, testable, and reusable",
      "explanation": "This demonstrates composition over inheritance in Godot for a tic-tac-toe cell. Instead of a deep inheritance hierarchy, we break functionality into focused components:\n\n**Benefits of Composition:**\n1. **Modularity** - Each component has a single responsibility\n2. **Reusability** - Components can be mixed and matched on different nodes\n3. **Testability** - Easy to test components in isolation\n4. **Flexibility** - Add/remove behaviors by adding/removing components\n5. **Maintainability** - Changes to one component don't affect others\n\n**Why Avoid Deep Inheritance:**\n- Hard to understand the full behavior (spread across multiple classes)\n- Fragile - changes to base classes break derived classes\n- Inflexible - can't easily mix behaviors from different inheritance chains\n- Diamond problem - conflicting behaviors from multiple inheritance\n\n**Component Pattern in Godot:**\nEach component is a separate node that can be attached to any parent. Components communicate through signals, keeping them loosely coupled. This mirrors how Godot itself is built - nodes are composed together rather than inherited from complex hierarchies.",
      "addedAt": "2026-01-16T05:10:45.007Z",
      "addedBy": "ai"
    },
    {
      "title": "Tic-Tac-Toe: Composition vs Inheritance",
      "language": "gdscript",
      "code": "# BAD: Inheritance-heavy approach\n# This creates a rigid hierarchy that's hard to extend\n\nclass_name BadGamePiece\nextends Node2D\n\n# Every piece inherits all this functionality, even if not needed\nvar health: int = 100\nvar damage: int = 10\nvar speed: float = 200.0\nvar team: String = \"\"\n\nfunc take_damage(amount: int): pass\nfunc move_to(position: Vector2): pass\nfunc attack(target: BadGamePiece): pass\n\nclass_name BadPlayer extends BadGamePiece:\n    # Inherits damage/health system it doesn't need for tic-tac-toe\n    pass\n\nclass_name BadAI extends BadGamePiece:\n    # Also inherits unnecessary functionality\n    pass\n\n---\n\n# GOOD: Composition approach\n# Each component handles one responsibility\n\n# Component 1: Handle piece placement and visual representation\nclass_name PieceVisual\nextends Node2D\n\nsignal piece_placed(position: Vector2)\n@export var piece_type: String = \"\"  # \"X\" or \"O\"\n@export var cell_position: Vector2\n\nfunc set_piece_type(type: String):\n    piece_type = type\n    update_visual()\n\nfunc update_visual():\n    # Update sprite/texture based on piece_type\n    pass\n\n---\n\n# Component 2: Handle player input\nclass_name PlayerInput\nextends Node\n\nsignal move_requested(cell_position: Vector2)\n\nfunc _input(event):\n    if event is InputEventMouseButton and event.pressed:\n        var cell_pos = world_to_cell(get_global_mouse_position())\n        move_requested.emit(cell_pos)\n\nfunc world_to_cell(world_pos: Vector2) -> Vector2:\n    # Convert mouse position to grid cell\n    return Vector2(\n        int(world_pos.x / 100), \n        int(world_pos.y / 100)\n    )\n\n---\n\n# Component 3: Handle AI decision making\nclass_name AIBrain\nextends Node\n\nsignal move_decided(cell_position: Vector2)\n@export var difficulty: String = \"easy\"  # easy, medium, hard\n\nfunc make_move(board_state: Array):\n    var best_move = Vector2(-1, -1)\n    \n    match difficulty:\n        \"easy\":\n            best_move = find_random_move(board_state)\n        \"medium\":\n            best_move = find_blocking_move(board_state)\n        \"hard\":\n            best_move = find_minimax_move(board_state)\n    \n    if best_move != Vector2(-1, -1):\n        move_decided.emit(best_move)\n\nfunc find_random_move(board_state: Array) -> Vector2:\n    # Find random empty cell\n    var empty_cells = []\n    for i in range(9):\n        if board_state[i] == \"\":\n            empty_cells.append(Vector2(i % 3, i / 3))\n    \n    if empty_cells.size() > 0:\n        return empty_cells[randi() % empty_cells.size()]\n    return Vector2(-1, -1)\n\nfunc find_blocking_move(board_state: Array) -> Vector2:\n    # AI logic to block player or win\n    # Implementation details...\n    return Vector2(-1, -1)\n\nfunc find_minimax_move(board_state: Array) -> Vector2:\n    # Advanced AI using minimax algorithm\n    # Implementation details...\n    return Vector2(-1, -1)\n\n---\n\n# Main game logic composes these components together\nclass_name TicTacToeGame\nextends Node2D\n\n@export var player_visual: PieceVisual\n@export var player_input: PlayerInput\n@export var ai_brain: AIBrain\n@export var ai_visual: PieceVisual\n\nvar game_state: GameState  # Resource from previous example\n\nfunc _ready():\n    # Connect components through composition\n    player_input.move_requested.connect(_on_player_move)\n    ai_brain.move_decided.connect(_on_ai_move)\n    \n    # Each component is focused and reusable\n    player_visual.piece_type = \"X\"\n    ai_visual.piece_type = \"O\"\n    ai_brain.difficulty = \"medium\"\n\nfunc _on_player_move(cell_pos: Vector2):\n    var index = cell_pos.y * 3 + cell_pos.x\n    if game_state.make_move(index, \"X\"):\n        player_visual.set_piece_type(\"X\")\n        \n        # AI takes turn\n        ai_brain.make_move(game_state.board_state)\n\nfunc _on_ai_move(cell_pos: Vector2):\n    var index = cell_pos.y * 3 + cell_pos.x\n    if game_state.make_move(index, \"O\"):\n        ai_visual.set_piece_type(\"O\")",
      "explanation": "This example demonstrates why composition is better than inheritance for game development:\n\n**Problems with Inheritance:**\n- **Rigid hierarchy**: Hard to change or extend\n- **Feature bloat**: Objects inherit functionality they don't need\n- **Deep coupling**: Changes in base classes affect all children\n- **Diamond problem**: Multiple inheritance conflicts\n\n**Benefits of Composition:**\n- **Modular**: Each component has one clear responsibility\n- **Flexible**: Easy to mix and match components\n- **Reusable**: Components can be used in different game objects\n- **Testable**: Each component can be tested independently\n- **Maintainable**: Changes are localized to specific components\n\n**Composition in Godot:**\n- Use nodes as components attached to a main object\n- Connect components through signals (loose coupling)\n- Each component focuses on one aspect (input, AI, visuals, etc.)\n- Easy to swap components (change AI difficulty, input methods)\n\n**Real-World Benefits:**\n- Want to add online multiplayer? Replace PlayerInput with NetworkInput\n- Want different AI difficulties? Just swap the AIBrain component\n- Want different visuals? Replace PieceVisual without touching logic\n- Want to add sound effects? Add an AudioComponent without changing existing code\n\nThis approach makes your code more maintainable and extensible, which is crucial for larger game projects.",
      "addedAt": "2026-01-16T05:12:05.347Z",
      "addedBy": "ai"
    }
  ]
}