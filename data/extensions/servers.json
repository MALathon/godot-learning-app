{
  "topicId": "servers",
  "resources": [
    {
      "title": "Godot Documentation - Server Architecture",
      "url": "https://docs.godotengine.org/en/stable/development/cpp/custom_servers.html",
      "type": "docs",
      "addedAt": "2026-01-16T05:09:49.413Z",
      "addedBy": "ai"
    },
    {
      "title": "Godot Engine Architecture Overview",
      "url": "https://docs.godotengine.org/en/stable/development/cpp/core_overview.html",
      "type": "docs",
      "addedAt": "2026-01-16T05:09:53.179Z",
      "addedBy": "ai"
    }
  ],
  "codeExamples": [
    {
      "title": "Understanding Godot's Server Architecture",
      "language": "gdscript",
      "code": "extends Node\nclass_name ServerDemo\n\nfunc _ready():\n    # Demonstrate how Godot's servers work behind the scenes\n    # These are the low-level systems that power the engine\n    \n    print(\"=== GODOT SERVER ARCHITECTURE DEMO ===\")\n    \n    # RENDERING SERVER - Handles all visual rendering\n    print(\"\\n--- Rendering Server ---\")\n    var rs = RenderingServer\n    print(\"Rendering backend: \", rs.get_rendering_device())\n    print(\"Frame count: \", rs.get_frame_setup_time_cpu())\n    \n    # PHYSICS SERVER 2D - Handles 2D physics simulation\n    print(\"\\n--- Physics Server 2D ---\")\n    var ps2d = PhysicsServer2D\n    \n    # Create a physics body directly through the server\n    # (normally nodes like RigidBody2D do this for you)\n    var body_rid = ps2d.body_create()\n    ps2d.body_set_mode(body_rid, PhysicsServer2D.BODY_MODE_DYNAMIC)\n    \n    # Create a collision shape\n    var shape_rid = ps2d.rectangle_shape_create()\n    ps2d.shape_set_data(shape_rid, Vector2(50, 50))\n    \n    print(\"Created physics body RID: \", body_rid)\n    print(\"Created shape RID: \", shape_rid)\n    \n    # AUDIO SERVER - Handles all audio processing\n    print(\"\\n--- Audio Server ---\")\n    var audio = AudioServer\n    print(\"Audio driver: \", audio.get_driver_name())\n    print(\"Output device: \", audio.get_output_device())\n    print(\"Sample rate: \", audio.get_mix_rate(), \" Hz\")\n    \n    # INPUT SERVER - Handles input events (internal)\n    print(\"\\n--- Input System ---\")\n    print(\"Mouse mode: \", Input.get_mouse_mode())\n    print(\"Connected joypads: \", Input.get_connected_joypads())\n\nfunc _process(_delta):\n    # Example: Query rendering server for performance info\n    if Engine.get_process_frames() % 60 == 0:  # Every second at 60fps\n        var rs = RenderingServer\n        var fps = Engine.get_frames_per_second()\n        var render_time = rs.get_frame_setup_time_cpu()\n        print(\"FPS: \", fps, \" | Render time: \", render_time, \"ms\")\n\n# Example: Custom server interaction for advanced users\nfunc create_custom_mesh():\n    var rs = RenderingServer\n    \n    # Create mesh data directly on the rendering server\n    var mesh_rid = rs.mesh_create()\n    \n    # Define vertices for a triangle\n    var vertices = PackedVector3Array([\n        Vector3(-1, -1, 0),\n        Vector3(1, -1, 0), \n        Vector3(0, 1, 0)\n    ])\n    \n    # Create surface arrays\n    var arrays = []\n    arrays.resize(Mesh.ARRAY_MAX)\n    arrays[Mesh.ARRAY_VERTEX] = vertices\n    \n    # Add surface to mesh\n    rs.mesh_add_surface_from_arrays(mesh_rid, RenderingServer.PRIMITIVE_TRIANGLES, arrays)\n    \n    print(\"Created custom mesh RID: \", mesh_rid)\n    return mesh_rid",
      "explanation": "This example demonstrates Godot's server architecture - the low-level systems that power the engine:\n\n**Key Servers:**\n- **RenderingServer**: Handles all visual rendering, GPU communication, and graphics resources\n- **PhysicsServer2D/3D**: Manages physics simulation, collision detection, and rigid body dynamics  \n- **AudioServer**: Processes audio mixing, effects, and output to audio drivers\n- **Input**: Handles keyboard, mouse, and controller input (though not directly called a \"server\")\n\n**Why This Matters:**\n- Servers run on separate threads for performance\n- High-level nodes (RigidBody2D, Sprite2D) are just convenient wrappers around server calls\n- Understanding servers helps you optimize performance and debug issues\n- Advanced users can call servers directly for maximum control\n\n**Real-World Usage:**\n- Most game development uses high-level nodes\n- Server calls are for performance-critical code, custom tools, or engine extensions\n- Useful for understanding what happens \"under the hood\" when you use nodes\n\nThis architecture makes Godot highly modular and efficient - each server specializes in one aspect of game engine functionality.",
      "addedAt": "2026-01-16T05:10:15.882Z",
      "addedBy": "ai"
    },
    {
      "title": "Understanding Godot's Server Architecture",
      "language": "gdscript",
      "code": "# Godot's server architecture - this shows how to interact with low-level servers\n# This demonstrates the separation between high-level nodes and low-level servers\n\nextends Node\n\nfunc _ready():\n    demonstrate_server_architecture()\n\nfunc demonstrate_server_architecture():\n    print(\"=== GODOT SERVER ARCHITECTURE DEMO ===\")\n    \n    # 1. RENDERING SERVER - handles all graphics\n    print(\"\\\\n1. RenderingServer (graphics):\")\n    var rendering_server = RenderingServer\n    \n    # Get viewport info (what you see is managed by RenderingServer)\n    var main_viewport = get_viewport().get_viewport_rid()\n    var viewport_info = rendering_server.viewport_get_render_info(main_viewport, RenderingServer.VIEWPORT_RENDER_INFO_TYPE_VISIBLE, RenderingServer.VIEWPORT_RENDER_INFO_DRAW_CALLS_IN_FRAME)\n    print(\"  - Draw calls this frame: \", viewport_info)\n    \n    # Create a simple mesh directly through the server\n    var mesh_rid = rendering_server.mesh_create()\n    print(\"  - Created mesh RID: \", mesh_rid)\n    \n    # 2. PHYSICS SERVER 2D - handles 2D physics simulation\n    print(\"\\\\n2. PhysicsServer2D (2D physics):\")\n    var physics_server = PhysicsServer2D\n    \n    # Create a physics body directly (what RigidBody2D uses internally)\n    var space = get_world_2d().space\n    var body = physics_server.body_create()\n    physics_server.body_set_space(body, space)\n    physics_server.body_set_mode(body, PhysicsServer2D.BODY_MODE_RIGID)\n    print(\"  - Created physics body RID: \", body)\n    \n    # 3. AUDIO SERVER - handles all sound\n    print(\"\\\\n3. AudioServer (sound):\")\n    var audio_server = AudioServer\n    \n    # Get audio driver info\n    print(\"  - Audio driver: \", audio_server.get_driver_name())\n    print(\"  - Sample rate: \", audio_server.get_mix_rate(), \" Hz\")\n    print(\"  - Audio buses: \", audio_server.get_bus_count())\n    \n    # 4. INPUT SERVER - handles input devices\n    print(\"\\\\n4. Input (input handling):\")\n    var input = Input\n    \n    # Get connected joysticks (managed by Input singleton)\n    print(\"  - Connected joysticks: \", input.get_connected_joypads())\n    \n    # 5. DISPLAY SERVER - handles window/display management  \n    print(\"\\\\n5. DisplayServer (window/display):\")\n    var display_server = DisplayServer\n    \n    print(\"  - Screen count: \", display_server.get_screen_count())\n    print(\"  - Primary screen size: \", display_server.screen_get_size(0))\n    \n    print(\"\\\\n=== WHY THIS MATTERS FOR GAME DEVELOPMENT ===\")\n    print(\"Nodes are high-level interfaces to these servers:\")\n    print(\"  - Sprite2D -> talks to RenderingServer\")\n    print(\"  - RigidBody2D -> talks to PhysicsServer2D\") \n    print(\"  - AudioStreamPlayer -> talks to AudioServer\")\n    print(\"  - Input events -> come from Input singleton\")\n    print(\"\\\\nUnderstanding servers helps you:\")\n    print(\"  - Optimize performance (fewer node layers)\")\n    print(\"  - Debug rendering/physics issues\")\n    print(\"  - Create custom low-level systems\")\n    print(\"  - Understand how Godot actually works internally\")\n\n# Example: Direct server usage for performance-critical code\nfunc create_many_sprites_efficiently():\n    # Instead of creating thousands of Sprite2D nodes (expensive)\n    # We can draw directly through RenderingServer (much faster)\n    \n    var canvas = get_canvas_item()\n    var texture = preload(\"res://icon.png\")\n    \n    # This bypasses the node system entirely\n    for i in range(1000):\n        var pos = Vector2(randf() * 800, randf() * 600)\n        RenderingServer.canvas_item_add_texture_rect(\n            canvas,                    # Canvas to draw on\n            Rect2(pos, Vector2(32, 32)), # Position and size\n            texture.get_rid()          # Texture resource ID\n        )\n\n# Example: Physics server for custom physics\nfunc create_custom_physics_body():\n    var physics = PhysicsServer2D\n    var space = get_world_2d().space\n    \n    # Create body\n    var body = physics.body_create()\n    physics.body_set_space(body, space)\n    physics.body_set_mode(body, PhysicsServer2D.BODY_MODE_KINEMATIC)\n    \n    # Create shape\n    var shape = physics.rectangle_shape_create()\n    physics.shape_set_data(shape, Vector2(50, 50))\n    \n    # Attach shape to body\n    physics.body_add_shape(body, shape)\n    physics.body_set_state(body, PhysicsServer2D.BODY_STATE_TRANSFORM, Transform2D(0, Vector2(400, 300)))\n    \n    return body",
      "explanation": "This code demonstrates Godot's server architecture - the low-level systems that power all the high-level nodes you interact with. \n\n**Key Concepts:**\n\n**What are Servers?**\n- Low-level C++ systems that handle core engine functionality\n- Nodes are essentially user-friendly wrappers around server functionality\n- Servers communicate via RIDs (Resource IDs) instead of object references\n\n**Main Servers:**\n1. **RenderingServer** - All graphics, meshes, textures, shaders\n2. **PhysicsServer2D/3D** - Physics simulation, collision detection  \n3. **AudioServer** - Sound mixing, playback, effects\n4. **DisplayServer** - Window management, input devices\n5. **Input** - Input event processing\n\n**Why This Matters:**\n- **Performance**: Direct server access bypasses node overhead\n- **Understanding**: Know what happens \"under the hood\" when you use nodes\n- **Debugging**: Server-level debugging for complex issues\n- **Custom Systems**: Build specialized systems that don't need full nodes\n\n**Real-World Use Cases:**\n- Particle systems (thousands of sprites efficiently)\n- Custom renderers (procedural meshes, shaders)\n- Physics optimization (custom collision shapes)\n- Audio processing (custom audio effects)\n\nThis architecture makes Godot both beginner-friendly (nodes) and powerful for experts (direct server access).",
      "addedAt": "2026-01-16T05:11:26.433Z",
      "addedBy": "ai"
    }
  ]
}